spring.application.name=Sell-the-old-Car
server.port=9000
server.address=0.0.0.0

# ===============================================
# DATABASE CONFIGURATION
# ===============================================
# WARNING: DO NOT use hardcoded database credentials in production!
# Set these as environment variables: DB_URL, DB_USERNAME, DB_PASSWORD
spring.datasource.url=${DB_URL:jdbc:postgresql://localhost:5432/carselling}
spring.datasource.username=${DB_USERNAME:postgres}
spring.datasource.password=${DB_PASSWORD:12345}
spring.datasource.hikari.auto-commit=false

spring.datasource.driver-class-name=org.postgresql.Driver

# ===============================================
# JPA & HIBERNATE CONFIGURATION
# ===============================================
spring.jpa.hibernate.ddl-auto=update



spring.jpa.show-sql=false
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.open-in-view=false

# ===============================================
# JWT SECURITY CONFIGURATION
# ===============================================
# WARNING: DO NOT use hardcoded secrets in production!
# Set these as environment variables: JWT_SECRET, JWT_EXPIRATION_MS, JWT_REFRESH_EXPIRATION_MS
app.jwt.secret=${JWT_SECRET:JDOq10NFlBlLKGcsvTnOP6vm8Ty9L7qCIYdU5g3HSef}
# JWT Token Expiration Configuration:
# Access token: 30 days = 2592000000 ms (Unified with Refresh Token for seamless UX)
# Refresh token: 30 days = 2592000000 ms
app.jwt.expiration-ms=${JWT_EXPIRATION_MS:2592000000}
app.jwt.refresh-token-expiration-ms=${JWT_REFRESH_EXPIRATION_MS:2592000000}

# ===============================================
# LOGGING CONFIGURATION
# ===============================================
# Suppress benign security warning for custom AuthenticationProvider
logging.level.org.springframework.security.config.annotation.authentication.configuration.InitializeUserDetailsBeanManagerConfigurer=ERROR
# Suppress noisy "Filter was not registered (disabled)" message for JWT filter
logging.level.org.springframework.boot.web.servlet.RegistrationBean=WARN
# Set more detailed logging for security and application packages
logging.level.org.springframework.security=INFO
logging.level.com.carselling.oldcar=INFO

# ===============================================
# DATABASE-BACKED MESSAGE BROKER (PostgreSQL only)
# ===============================================
# Using PostgreSQL for all chat data persistence

# ===============================================
# WEBSOCKET CONFIGURATION
# ===============================================
# WebSocket connection settings
spring.websocket.allowedOrigins=${WEBSOCKET_ALLOWED_ORIGINS:http://localhost:3000,http://localhost:8080}
spring.websocket.broker.host=${WEBSOCKET_BROKER_HOST:localhost}
spring.websocket.broker.port=${WEBSOCKET_BROKER_PORT:61613}

# Chat system settings
app.chat.max-message-length=1000
app.chat.max-messages-per-minute=30
app.chat.typing-timeout=10000
app.chat.online-timeout=300000

# ===============================================
# REDIS CONFIGURATION (OPTIONAL)
# ===============================================
# Redis is used for caching and rate limiting. If Redis is not available,
# the application will fall back to in-memory caching.
# WARNING: DO NOT use hardcoded Redis credentials in production!
# Set these as environment variables: REDIS_HOST, REDIS_PORT, REDIS_PASSWORD
spring.data.redis.host=${REDIS_HOST:localhost}
spring.data.redis.port=${REDIS_PORT:6379}
spring.data.redis.password=${REDIS_PASSWORD:}
spring.data.redis.timeout=${REDIS_TIMEOUT:2000ms}
spring.data.redis.database=${REDIS_DATABASE:0}

# Redis connection pool settings (Lettuce)
spring.data.redis.lettuce.pool.max-active=${REDIS_POOL_MAX_ACTIVE:8}
spring.data.redis.lettuce.pool.max-idle=${REDIS_POOL_MAX_IDLE:8}
spring.data.redis.lettuce.pool.min-idle=${REDIS_POOL_MIN_IDLE:0}
spring.data.redis.lettuce.pool.max-wait=${REDIS_POOL_MAX_WAIT:-1ms}
spring.data.redis.lettuce.shutdown-timeout=${REDIS_SHUTDOWN_TIMEOUT:100ms}

# Application-specific Redis settings
app.redis.enabled=false
app.redis.fallback-to-memory=${REDIS_FALLBACK_ENABLED:true}
app.redis.health-check.enabled=${REDIS_HEALTH_CHECK:true}
app.redis.health-check.interval=${REDIS_HEALTH_CHECK_INTERVAL:30s}
management.health.redis.enabled=false
management.health.mail.enabled=false
management.health.elasticsearch.enabled=false

# ===============================================
# RATE LIMITING CONFIGURATION
# ===============================================
# Rate limiting using Redis-backed Bucket4j
# Set RATE_LIMIT_ENABLED=false to disable rate limiting
app.rate-limit.enabled=${RATE_LIMIT_ENABLED:true}

# Bucket configuration
# Maximum number of requests allowed in the time window
app.rate-limit.capacity=${RATE_LIMIT_CAPACITY:100}

# Number of tokens to refill per time period
app.rate-limit.refill-tokens=${RATE_LIMIT_REFILL_TOKENS:10}

# Refill period in minutes (how often to add refill-tokens)
app.rate-limit.refill-period-minutes=${RATE_LIMIT_REFILL_PERIOD:1}

# Fail-safe behavior when rate limiting encounters errors
# true = allow requests through on errors, false = block requests on errors
app.rate-limit.fail-open=${RATE_LIMIT_FAIL_OPEN:true}

# Enable detailed logging for rate limiting (useful for debugging)
app.rate-limit.debug-logging=${RATE_LIMIT_DEBUG_LOGGING:false}

# ===============================================
# EMAIL CONFIGURATION
# ===============================================
# WARNING: DO NOT use hardcoded email credentials in production!
# Set these as environment variables: MAIL_HOST, MAIL_PORT, MAIL_USERNAME, MAIL_PASSWORD
spring.mail.host=smtp.gmail.com
spring.mail.port=587
spring.mail.username=yashborse432005@gmail.com
spring.mail.password=zmjnvveurgvmoavf
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true
spring.mail.properties.mail.smtp.starttls.required=true


# ===============================================
# ELASTICSEARCH / OPENSEARCH CONFIGURATION
# ===============================================
# Enable OpenSearch via property or env var
elasticsearch.enabled=${ELASTICSEARCH_ENABLED:false}

# OpenSearch Connection Settings
opensearch.host=${OPENSEARCH_HOST:localhost}
opensearch.port=${OPENSEARCH_PORT:9200}
opensearch.scheme=${OPENSEARCH_SCHEME:http}
opensearch.username=${OPENSEARCH_USERNAME:}
opensearch.password=${OPENSEARCH_PASSWORD:}

# Spring Data Elasticsearch Repositories (Enable if using repositories)
# We are currently using VehicleSearchRepository which uses the client directly
spring.data.elasticsearch.repositories.enabled=false

# Disable Redis repositories to prevent conflicts with JPA repositories
spring.data.redis.repositories.enabled=false

# ===============================================
# ACTUATOR CONFIGURATION
# ===============================================
management.endpoints.web.exposure.include=health,info,metrics


logging.level.root=INFO
logging.level.com.myapp=DEBUG
debug=true



# ===============================================
# MULTIPART FILE UPLOAD CONFIGURATION
# ===============================================
spring.servlet.multipart.enabled=true
spring.servlet.multipart.max-file-size=200MB
spring.servlet.multipart.max-request-size=200MB


b2.applicationKeyId=b34ee0942e01
b2.applicationKey=0036bbddf5c00da845de7d17310ec76a4ee77f43d2
b2.bucketId=carwala-car-images
b2.cdnDomain=https://yashborse.me

# ===============================================
# SWAGGER / SPRINGDOC CONFIGURATION
# ===============================================
springdoc.swagger-ui.enabled=false

# ===============================================
# FIREBASE CONFIGURATION
# ===============================================
# Firebase Push Notifications (disabled until serviceAccountKey.json is configured)
app.firebase.enabled=${FIREBASE_ENABLED:false}